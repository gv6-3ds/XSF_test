#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Modelica.Blocks.Examples.PID_Controller
 Dymola Version 2023x, 2022-10-07 translated this at Mon Feb  6 17:22:09 2023

  OutputCPUtime = true;
 */

#include <matrixop.h>
#include "matrixop.c"
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

  BreakSectionDef(1);
#define NX_    6
#define NX2_   0
#define NU_    0
#define NY_    2
#define NW_    77
#define NWP_   53
#define NP_    37
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   1
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 173961479
#define NHash2_ -2004946249
#define NHash3_ -567722443
#define NI_    0
#define NRelF_ 2
#define NRel_  2
#define NTim_  5
#define NSamp_ 0
#define NCons_ 0
#define NA_    51
#define SizePre_ 0
#define SizeEq_ 2
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 45
#define NGlobalHelpI_ 23
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Modelica.Blocks.Examples.PID_Controller";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "C:/ProgramData/DassaultSystemes/Licenses/DSLicSrv.txt";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[14]={5 , 2 , 1 , 2 , 1 , 3 , 1 , 4 , 1 , 5 , 1 , 6
   , 0 , 0};
static int QJacobianGrp0[7]={1, 0, 1, 0, 1, 0, 0};
static int QJacobianGrp1[7]={3, 3, 3, 0, 3, 0, 0};
static int QJacobianGrp2[6]={1, 4 , 2 , 3 , 5 , 0};
static int QJacobianGrp3[7]={0, 0, 5, 5, 5, 0, 0};
static int QJacobianGrp4[7]={6, 0, 6, 0, 6, 0, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[6]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{1, QJacobianGrp2},{0, QJacobianGrp3},{0, 
  QJacobianGrp4},{0,0}};
DYMOLA_STATIC double QJacobianCD_[7]={0  , 44 , 55 , 60 , 63 , 64 , 63};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
DYNX(Y_,0) = CurrentClockTime;
if (DYNEvent) DYNX(Y_,1) += 1;
InitialSection
#if defined(DynSimStruct)
DYNX(W_,61) = 0;
DYNX(W_,66) = 0;
DYNX(F_,4) = 0;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,0) = 2;
DYNX(W_,2) = false;
DYNX(W_,6) = 1;
DYNX(W_,13) = true;
DYNX(W_,14) = false;
DYNX(W_,17) = false;
DYNX(W_,18) = false;
DYNX(W_,24) = 3;
DYNX(W_,25) = false;
DYNX(W_,27) = 0.0001;
DYNX(W_,28) = 4;
DYNX(W_,29) = false;
DYNX(W_,30) = 3;
DYNX(W_,32) = 1;
DYNX(W_,45) = false;
DYNX(W_,46) = false;
DYNX(W_,51) = false;
DYNX(W_,3) = 2;
DYNX(W_,4) = 2;
DYNX(W_,5) = false;
DYNX(W_,11) = false;
DYNX(W_,12) = 2;
DYNX(W_,19) = 2;
DYNX(W_,47) = 3;
DYNX(W_,50) = 0;
DYNX(W_,52) = 0;
DYNX(W_,22) = 0;
DYNX(W_,26) = 0;
DYNX(W_,49) = 0;
DYNX(W_,21) = false;
DYNX(W_,48) = false;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,1) =  -DYNX(DP_,4);
DYNX(W_,7) = DYNX(DP_,5);
DYNX(W_,8) = DYNX(DP_,1);
DYNX(W_,9) = DYNX(DP_,4);
DYNX(W_,10) = DYNX(W_,1);
AssertModelica(DYNX(W_,9) >= DYNX(W_,10),"PI.limiter.uMax >= PI.limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,9), true, 0)),") < uMin (="),Real2String2(DYNX(W_,10), 
  true, 0)),")"));
DYNX(W_,15) = DYNX(DP_,9);
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,2),"PI.Ti");
DYNX(W_,16) = DYNX(DYNhelp,0);
DYNX(W_,20) = DYNX(DP_,10);
DYNX(W_,23) = divinvGuarded(DYNX(DP_,1)*DYNX(DP_,7),"PI.k*PI.Ni");
DYNX(W_,31) = DYNX(DP_,0);
DYNX(W_,33) = DYNX(W_,31);
DYNX(W_,34) = DYNX(DP_,31);
DYNX(W_,35) = DYNX(DP_,32);
BoundParameterConstantSection
DYNX(DYNhelp,1) = divinvGuarded(DYNX(W_,34),"kinematicPTP.p_qd_max[1]");
DYNX(W_,38) = DYNX(DYNhelp,1)*DYNX(W_,33);
DYNX(DYNhelp,2) = fabs(DYNX(W_,38));
DYNX(DYNhelp,3) = divinvGuarded(DYNX(DYNhelp,2),"abs(kinematicPTP.aux1[1])");
DYNX(W_,36) = DYNX(DYNhelp,3);
DYNX(DYNhelp,4) = divinvGuarded(DYNX(W_,35),"kinematicPTP.p_qdd_max[1]");
DYNX(W_,39) = DYNX(DYNhelp,4)*DYNX(W_,33);
DYNX(DYNhelp,5) = fabs(DYNX(W_,39));
DYNX(DYNhelp,6) = divinvGuarded(DYNX(DYNhelp,5),"abs(kinematicPTP.aux2[1])");
DYNX(W_,37) = DYNX(DYNhelp,6);
DYNX(DYNhelp,7) = divinvGuarded(DYNX(W_,37),"kinematicPTP.sdd_max");
DYNX(W_,41) = DYNX(DYNhelp,7)*DYNX(W_,36);
DYNX(DYNhelp,8) = divinvGuarded(DYNX(W_,37),"kinematicPTP.sdd_max");
DYNX(W_,40) = sqrtGuarded(DYNX(DYNhelp,8),"1/kinematicPTP.sdd_max");
DYNX(W_,44) = DYNX(W_,41) >= DYNX(W_,40);
DYNX(W_,42) = IF DYNX(W_,44) THEN DYNX(W_,40) ELSE divinvGuarded(DYNX(W_,36),
  "kinematicPTP.sd_max");
DYNX(W_,43) = IF DYNX(W_,44) THEN DYNX(W_,40)+DYNX(W_,40) ELSE DYNX(W_,42)+
  DYNX(W_,41);
BoundParameterSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,0) = DYNX(W_,20);
DYNX(X_,5) = DYNX(DP_,35);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(F_,4) = 0;
DYNX(F_,0) = 0;
DYNX(X_,5) = DYNX(DP_,35);
 /* Linear system of equations to solve. */
DYNX(W_,62) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,16)," -PI.I.k", 0.0,"0.0", DYNX(W_,62),
  "PI.I.u");
 /* End of Equation Block */ 

DYNX(W_,72) = DYNX(W_,66);
DYNX(W_,65) = DYNX(DP_,36)-DYNX(DP_,30)*DYNX(W_,72);
DYNX(W_,55) = DYNX(DP_,26)*DYNX(W_,66)-DYNX(W_,65);
if (DymolaHomotopyLambda==0){
  BreakSectionCallNew(1);
}
else {
  /* Introducing 1 common subexpressions used in 1 expressions */
  /* Of the common subexpressions 0 are reals, 0 are integers, and 1
     are booleans. */
  { /* Non-linear system of equations to solve. */
  /* Tag: initialization.nonlinear[1] */
  const char*const varnames_[]={"PI.limiter.u"};
  const double nominal_[]={1.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 0, 1, -2, 
    DYNX(DYNhelp,9), 35, DYNX(did_->helpvari_vec,0), 23);
  SetInitVectorSimple(x__, 1, DYNX(W_,61), 0, 0);
  Residues;
  DYNX(DYNhelp,44) = GreaterS(DYNX(W_,61),"PI.limiter.u", DYNX(W_,9),
    "PI.limiter.uMax", 0);
  SetVector(residue__, 1, DYNX(W_,55)-homotopy(IF DYNX(DYNhelp,44) THEN 
    DYNX(W_,9) ELSE IF LessS(DYNX(W_,61),"PI.limiter.u", DYNX(W_,10),
    "PI.limiter.uMin", 1) THEN DYNX(W_,10) ELSE DYNX(W_,61), DYNX(W_,61)));

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  SetMatrixLeading(Jacobian__, 1, 1, 1,  -homotopy(IF DYNX(DYNhelp,44) THEN 0.0
     ELSE IF LessS(DYNX(W_,61),"PI.limiter.u", DYNX(W_,10),"PI.limiter.uMin", 1)
     THEN 0.0 ELSE 1.0, 1.0));

  SolveNonLinearSystemOfEquationsInit(Jacobian__, 0, 0, 0, residue__, x__,"Tag: initialization.nonlinear[1]");
  DYNX(W_,61) = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
  DYNNonlinearSolverStatistics(0, DYNX(W_,73), DYNX(W_,74), DYNX(W_,75), 
    DYNX(W_,76));
   /* End of Non-Linear Equation Block */ }



}
DYNX(W_,64) = DYNX(DP_,24)*DYNX(W_,55)+DYNX(DP_,25)*DYNX(W_,61);
DYNX(W_,63) = DYNX(W_,23)*DYNX(W_,64);
 /* Linear system of equations to solve. */
DYNX(X_,2) = 0.0;
SolveScalarLinearParametric( -DYNX(DP_,22)," -PI.addI.k2", DYNX(DP_,21)*
  DYNX(X_,5)+DYNX(DP_,23)*DYNX(W_,63)-DYNX(W_,62),"PI.addI.k1*PI.addI.u1+PI.addI.k3*PI.addI.u3-PI.addI.y",
   DYNX(X_,2),"inertia1.w");
 /* End of Equation Block */ 

DYNX(W_,69) = DYNX(DP_,28)*DYNX(X_,4);
DYNX(W_,68) = DYNX(W_,65)-DYNX(W_,69);
 /* Linear system of equations to solve. */
DYNX(X_,3) = 0;
SolveScalarLinearParametric( -DYNX(DP_,27)," -spring.c",  -(DYNX(W_,68)+
  DYNX(DP_,27)*DYNX(DP_,29))," -(spring.tau_c+spring.c*spring.phi_rel0)", 
  DYNX(X_,3),"spring.phi_rel");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(W_,60) = 0.0;
SolveScalarLinearParametric( -DYNX(DP_,20)," -PI.addFF.k1", DYNX(W_,15)*
  DYNX(DP_,19)-DYNX(W_,61),"PI.addFF.k2*PI.addFF.u2-PI.addFF.y", DYNX(W_,60),
  "PI.gainPID.y");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(W_,59) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,8)," -PI.gainPID.k",  -DYNX(W_,60),
  " -PI.gainPID.y", DYNX(W_,59),"PI.gainPID.u");
 /* End of Equation Block */ 

DYNX(W_,57) = DYNX(W_,7)*DYNX(X_,5)+DYNX(DP_,13)*DYNX(X_,2);
DYNX(W_,58) = DYNX(DP_,14)*DYNX(W_,57);
 /* Linear system of equations to solve. */
DYNX(X_,0) = DYNX(W_,20);
SolveScalarLinearParametric( -DYNX(DP_,17)," -PI.addPID.k3", DYNX(DP_,15)*
  DYNX(W_,58)+DYNX(DP_,16)*DYNX(DP_,18)-DYNX(W_,59),"PI.addPID.k1*PI.addPID.u1+PI.addPID.k2*PI.addPID.u2-PI.addPID.y",
   DYNX(X_,0),"PI.I.y");
 /* End of Equation Block */ 

InitialSection
InitialSection2
DYNX(W_,54) = IF LessTime(DYNX(DP_,33), 0) THEN 0 ELSE IF DYNX(W_,44) THEN (IF 
  LessTime(DYNX(W_,40)+DYNX(DP_,33), 1) THEN DYNX(W_,37) ELSE IF LessTime(
  DYNX(W_,43)+DYNX(DP_,33), 2) THEN  -DYNX(W_,37) ELSE 0) ELSE IF LessTime(
  DYNX(W_,41)+DYNX(DP_,33), 3) THEN DYNX(W_,37) ELSE IF LessTime(DYNX(W_,42)+
  DYNX(DP_,33), 4) THEN 0 ELSE IF LessTime(DYNX(W_,43)+DYNX(DP_,33), 2) THEN  -
  DYNX(W_,37) ELSE 0;
DYNX(W_,53) = DYNX(W_,54)*DYNX(W_,33);
DYNX(F_,5) = DYNX(DP_,34)*DYNX(W_,53);
DYNX(F_,2) = DYNX(W_,66);
DYNX(F_,3) = DYNX(X_,4);
DYNX(F_,1) = DYNX(X_,2);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,54) = IF LessTime(DYNX(DP_,33), 0) THEN 0 ELSE IF DYNX(W_,44) THEN (IF 
  LessTime(DYNX(W_,40)+DYNX(DP_,33), 1) THEN DYNX(W_,37) ELSE IF LessTime(
  DYNX(W_,43)+DYNX(DP_,33), 2) THEN  -DYNX(W_,37) ELSE 0) ELSE IF LessTime(
  DYNX(W_,41)+DYNX(DP_,33), 3) THEN DYNX(W_,37) ELSE IF LessTime(DYNX(W_,42)+
  DYNX(DP_,33), 4) THEN 0 ELSE IF LessTime(DYNX(W_,43)+DYNX(DP_,33), 2) THEN  -
  DYNX(W_,37) ELSE 0;
DYNX(W_,53) = DYNX(W_,54)*DYNX(W_,33);
DYNX(F_,5) = DYNX(DP_,34)*DYNX(W_,53);
DYNX(W_,57) = DYNX(W_,7)*DYNX(X_,5)+DYNX(DP_,13)*DYNX(X_,2);
DYNX(W_,58) = DYNX(DP_,14)*DYNX(W_,57);
DYNX(W_,59) = DYNX(DP_,15)*DYNX(W_,58)+DYNX(DP_,16)*DYNX(DP_,18)+DYNX(DP_,17)*
  DYNX(X_,0);
DYNX(W_,60) = DYNX(W_,8)*DYNX(W_,59);
DYNX(W_,61) = DYNX(DP_,20)*DYNX(W_,60)+DYNX(W_,15)*DYNX(DP_,19);
DYNX(W_,55) = IF GreaterS(DYNX(W_,61),"PI.limiter.u", DYNX(W_,9),
  "PI.limiter.uMax", 0) THEN DYNX(W_,9) ELSE IF LessS(DYNX(W_,61),"PI.limiter.u",
   DYNX(W_,10),"PI.limiter.uMin", 1) THEN DYNX(W_,10) ELSE DYNX(W_,61);
DYNX(W_,68) = DYNX(DP_,27)*(DYNX(X_,3)-DYNX(DP_,29));
DYNX(W_,69) = DYNX(DP_,28)*DYNX(X_,4);
DYNX(W_,65) = DYNX(W_,68)+DYNX(W_,69);
 /* Linear system of equations to solve. */
DYNX(W_,66) = RememberSimple_(DYNX(W_,66), 0);
SolveScalarLinearParametric(DYNX(DP_,26),"inertia1.J", DYNX(W_,55)+DYNX(W_,65),
  "inertia1.flange_a.tau+inertia1.flange_b.tau", DYNX(W_,66),"inertia1.a");
 /* End of Equation Block */ 

DYNX(F_,2) = DYNX(W_,66);
 /* Linear system of equations to solve. */
DYNX(W_,72) = RememberSimple_(DYNX(W_,72), 1);
SolveScalarLinearParametric(DYNX(DP_,30),"inertia2.J", DYNX(DP_,36)-DYNX(W_,65),
  "inertia2.flange_b.tau-spring.tau", DYNX(W_,72),"der(inertia2.w)");
 /* End of Equation Block */ 

DYNX(F_,4) = DYNX(W_,72)-DYNX(W_,66);
DYNX(F_,3) = DYNX(X_,4);
DYNX(F_,1) = DYNX(X_,2);
DYNX(W_,64) = DYNX(DP_,24)*DYNX(W_,55)+DYNX(DP_,25)*DYNX(W_,61);
DYNX(W_,63) = DYNX(W_,23)*DYNX(W_,64);
DYNX(W_,62) = DYNX(DP_,21)*DYNX(X_,5)+DYNX(DP_,22)*DYNX(X_,2)+DYNX(DP_,23)*
  DYNX(W_,63);
DYNX(F_,0) = DYNX(W_,16)*DYNX(W_,62);

AcceptedSection1

AcceptedSection2
DYNX(W_,70) = DYNX(X_,3)+DYNX(X_,1);
DYNX(W_,71) = DYNX(X_,4)+DYNX(X_,2);
DYNX(W_,56) = DYNX(X_,5)-DYNX(X_,2);
DYNX(W_,67) = DYNX(W_,69)*DYNX(X_,4);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("driveAngle", "Reference distance to move [rad|deg]", 0, \
1.570796326794897, 0.0,0.0,0.0,0,560)
DeclareAlias2("PI.u_s", "Connector of setpoint input signal [rad/s]", \
"integrator.y", 1, 1, 5, 0)
DeclareAlias2("PI.u_m", "Connector of measurement input signal [rad/s]", \
"inertia1.w", 1, 1, 2, 0)
DeclareVariable("PI.y", "Connector of actuator output signal [N.m]", 55, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("PI.controlError", "Control error (set point - measurement) [rad/s]",\
 56, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PI.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 0, 2, 1.0,4.0,0.0,0,517)
DeclareParameter("PI.k", "Gain of controller [1]", 1, 100, 0.0,1E+100,0.0,0,560)
DeclareParameter("PI.Ti", "Time constant of Integrator block [s]", 2, 0.1, 1E-60,\
1E+100,0.0,0,560)
DeclareParameter("PI.Td", "Time constant of Derivative block [s]", 3, 0.1, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("PI.yMax", "Upper limit of output", 4, 12, 0.0,0.0,0.0,0,560)
DeclareVariable("PI.yMin", "Lower limit of output", 1, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("PI.wp", "Set-point weight for Proportional block (0..1)", 5, 1,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("PI.wd", "Set-point weight for Derivative block (0..1)", 6, 0, \
0.0,1E+100,0.0,0,560)
DeclareParameter("PI.Ni", "Ni*Ti is time constant of anti-windup compensation", 7,\
 0.1, 1E-13,1E+100,0.0,0,560)
DeclareParameter("PI.Nd", "The higher Nd, the more ideal the derivative block", 8,\
 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("PI.withFeedForward", "Use feed-forward input? [:#(type=Boolean)]",\
 2, false, 0.0,0.0,0.0,0,515)
DeclareParameter("PI.kFF", "Gain of feed-forward input", 9, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("PI.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 2, 1.0,4.0,0.0,0,517)
DeclareParameter("PI.xi_start", "Initial or guess value for integrator output (= integrator state)",\
 10, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.xd_start", "Initial or guess value for state of derivative block",\
 11, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.y_start", "Initial value of output", 12, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("PI.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 4, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("PI.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 5, false, 0.0,0.0,0.0,0,515)
DeclareVariable("PI.unitTime", "[s]", 6, 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("PI.addP.u1", "Connector of Real input signal 1 [rad/s]", \
"integrator.y", 1, 1, 5, 0)
DeclareAlias2("PI.addP.u2", "Connector of Real input signal 2 [rad/s]", \
"inertia1.w", 1, 1, 2, 0)
DeclareVariable("PI.addP.y", "Connector of Real output signal", 57, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("PI.addP.k1", "Gain of input signal 1", 7, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("PI.addP.k2", "Gain of input signal 2", 13, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.P.k", "Gain value multiplied with input signal [1]", 14, 1,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("PI.P.u", "Input signal connector", "PI.addP.y", 1, 5, 57, 0)
DeclareVariable("PI.P.y", "Output signal connector", 58, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PI.gainPID.k", "Gain value multiplied with input signal [1]", 8,\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("PI.gainPID.u", "Input signal connector", 59, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PI.gainPID.y", "Output signal connector", 60, 0.0, 0.0,0.0,0.0,\
0,512)
DeclareParameter("PI.addPID.k1", "Gain of input signal 1", 15, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.addPID.k2", "Gain of input signal 2", 16, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.addPID.k3", "Gain of input signal 3", 17, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PI.addPID.u1", "Connector of Real input signal 1", "PI.P.y", 1, 5,\
 58, 0)
DeclareAlias2("PI.addPID.u2", "Connector of Real input signal 2", "PI.Dzero.k", 1,\
 7, 18, 0)
DeclareAlias2("PI.addPID.u3", "Connector of Real input signal 3", "PI.I.y", 1, 1,\
 0, 0)
DeclareAlias2("PI.addPID.y", "Connector of Real output signal", "PI.gainPID.u", 1,\
 5, 59, 0)
DeclareVariable("PI.limiter.uMax", "Upper limits of input signals", 9, 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("PI.limiter.uMin", "Lower limits of input signals", 10, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("PI.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 11, false, 0.0,0.0,0.0,0,515)
DeclareVariable("PI.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 12, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("PI.limiter.u", "Connector of Real input signal", 61, 0, \
0.0,0.0,0.0,0,576)
DeclareAlias2("PI.limiter.y", "Connector of Real output signal [N.m]", "PI.y", 1,\
 5, 55, 0)
DeclareAlias2("PI.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "PI.limiter.u", 1, 5, 61, 1024)
DeclareVariable("PI.with_I", "[:#(type=Boolean)]", 13, true, 0.0,0.0,0.0,0,1539)
DeclareVariable("PI.with_D", "[:#(type=Boolean)]", 14, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("PI.Dzero.k", "Constant output value", 18, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("PI.Dzero.y", "Connector of Real output signal", "PI.Dzero.k", 1, 7,\
 18, 0)
DeclareParameter("PI.FFzero.k", "Constant output value", 19, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("PI.FFzero.y", "Connector of Real output signal", "PI.FFzero.k", 1,\
 7, 19, 0)
DeclareAlias2("PI.addFF.u1", "Connector of Real input signal 1", "PI.gainPID.y", 1,\
 5, 60, 0)
DeclareAlias2("PI.addFF.u2", "Connector of Real input signal 2", "PI.FFzero.k", 1,\
 7, 19, 0)
DeclareAlias2("PI.addFF.y", "Connector of Real output signal", "PI.limiter.u", 1,\
 5, 61, 0)
DeclareParameter("PI.addFF.k1", "Gain of input signal 1", 20, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("PI.addFF.k2", "Gain of input signal 2", 15, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PI.I.k", "Integrator gain [1]", 16, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PI.I.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 17, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PI.I.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 18, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PI.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 19, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("PI.I.y_start", "Initial or guess value of output (= state)", 20,\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PI.I.u", "Connector of Real input signal", 62, 0.0, 0.0,0.0,0.0,\
0,512)
DeclareState("PI.I.y", "Connector of Real output signal", 0, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("PI.I.der(y)", "der(Connector of Real output signal)", 0, 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("PI.I.local_reset", "[:#(type=Boolean)]", 21, false, 0.0,0.0,0.0,\
0,1539)
DeclareVariable("PI.I.local_set", "", 22, 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("PI.addI.k1", "Gain of input signal 1", 21, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.addI.k2", "Gain of input signal 2", 22, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.addI.k3", "Gain of input signal 3", 23, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PI.addI.u1", "Connector of Real input signal 1 [rad/s]", \
"integrator.y", 1, 1, 5, 0)
DeclareAlias2("PI.addI.u2", "Connector of Real input signal 2 [rad/s]", \
"inertia1.w", 1, 1, 2, 0)
DeclareVariable("PI.addI.u3", "Connector of Real input signal 3", 63, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("PI.addI.y", "Connector of Real output signal", "PI.I.u", 1, 5, 62,\
 0)
DeclareAlias2("PI.addSat.u1", "Connector of Real input signal 1 [N.m]", "PI.y", 1,\
 5, 55, 0)
DeclareAlias2("PI.addSat.u2", "Connector of Real input signal 2", "PI.limiter.u", 1,\
 5, 61, 0)
DeclareVariable("PI.addSat.y", "Connector of Real output signal", 64, 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("PI.addSat.k1", "Gain of input signal 1", 24, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.addSat.k2", "Gain of input signal 2", 25, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("PI.gainTrack.k", "Gain value multiplied with input signal [1]",\
 23, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("PI.gainTrack.u", "Input signal connector", "PI.addSat.y", 1, 5, 64,\
 0)
DeclareAlias2("PI.gainTrack.y", "Output signal connector", "PI.addI.u3", 1, 5, 63,\
 0)
DeclareAlias2("inertia1.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 1, 1, 4)
DeclareAlias2("inertia1.flange_a.tau", "Cut torque in the flange [N.m]", "PI.y", 1,\
 5, 55, 132)
DeclareAlias2("inertia1.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 1, 1, 4)
DeclareVariable("inertia1.flange_b.tau", "Cut torque in the flange [N.m]", 65, \
0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("inertia1.J", "Moment of inertia [kg.m2]", 26, 1, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("inertia1.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 24, 3, 1.0,5.0,0.0,0,1541)
DeclareState("inertia1.phi", "Absolute rotation angle of component [rad|deg]", 1,\
 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia1.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareState("inertia1.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 2, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("inertia1.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inertia1.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 66, 0, 0.0,0.0,0.0,0,528)
DeclareVariable("torque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 25, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("torque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 1, 1, 4)
DeclareAlias2("torque.flange.tau", "Cut torque in the flange [N.m]", "PI.y", -1,\
 5, 55, 132)
DeclareVariable("torque.phi_support", "Absolute angle of support flange [rad|deg]",\
 26, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("torque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "PI.y", 1, 5, 55, 0)
DeclareParameter("spring.c", "Spring constant [N.m/rad]", 27, 10000.0, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("spring.d", "Damping constant [N.m.s/rad]", 28, 100, 0.0,1E+100,\
0.0,0,560)
DeclareParameter("spring.phi_rel0", "Unstretched spring angle [rad|deg]", 29, 0,\
 0.0,0.0,0.0,0,560)
DeclareState("spring.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 3, 0, 0.0,0.0,0.0001,0,544)
DeclareDerivative("spring.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 3, 0.0, 0.0,0.0,0.0,0,512)
DeclareState("spring.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 4, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("spring.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 4, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("spring.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "spring.der(w_rel)", 1, 6, 4, 0)
DeclareAlias2("spring.tau", "Torque between flanges (= flange_b.tau) [N.m]", \
"inertia1.flange_b.tau", 1, 5, 65, 0)
DeclareAlias2("spring.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 1, 1, 4)
DeclareAlias2("spring.flange_a.tau", "Cut torque in the flange [N.m]", \
"inertia1.flange_b.tau", -1, 5, 65, 132)
DeclareAlias2("spring.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia2.phi", 1, 5, 70, 4)
DeclareAlias2("spring.flange_b.tau", "Cut torque in the flange [N.m]", \
"inertia1.flange_b.tau", 1, 5, 65, 132)
DeclareVariable("spring.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 27, 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("spring.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 28, 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("spring.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 29, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("spring.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 67, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("spring.tau_c", "Spring torque [N.m]", 68, 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("spring.tau_d", "Damping torque [N.m]", 69, 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("inertia2.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia2.phi", 1, 5, 70, 4)
DeclareAlias2("inertia2.flange_a.tau", "Cut torque in the flange [N.m]", \
"inertia1.flange_b.tau", -1, 5, 65, 132)
DeclareAlias2("inertia2.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia2.phi", 1, 5, 70, 4)
DeclareAlias2("inertia2.flange_b.tau", "Cut torque in the flange [N.m]", \
"loadTorque.tau_constant", 1, 7, 36, 132)
DeclareParameter("inertia2.J", "Moment of inertia [kg.m2]", 30, 2, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("inertia2.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 30, 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("inertia2.phi", "Absolute rotation angle of component [rad|deg]",\
 70, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia2.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "inertia2.w", 1, 5, 71, 0)
DeclareVariable("inertia2.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 71, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inertia2.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 72, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia2.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia2.der(w)", 1, 5, 72, 0)
DeclareVariable("kinematicPTP.deltaq[1]", "Distance to move [rad]", 31, 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("kinematicPTP.qd_max[1]", "Maximum velocities der(q)", 31, 1, \
1E-60,1E+100,0.0,0,560)
DeclareParameter("kinematicPTP.qdd_max[1]", "Maximum accelerations der(qd)", 32,\
 1, 1E-60,1E+100,0.0,0,560)
DeclareParameter("kinematicPTP.startTime", "Time instant at which movement starts [s]",\
 33, 0.5, 0.0,0.0,0.0,0,560)
DeclareVariable("kinematicPTP.nout", "Number of outputs [:#(type=Integer)]", 32,\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("kinematicPTP.y[1]", "Connector of Real output signals", 53, 0.0,\
 0.0,0.0,0.0,0,640)
DeclareVariable("kinematicPTP.p_deltaq[1]", "[rad]", 33, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.p_qd_max[1]", "", 34, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.p_qdd_max[1]", "", 35, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.sd_max", "", 36, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.sdd_max", "", 37, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.sdd", "", 54, 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("kinematicPTP.aux1[1]", "", 38, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.aux2[1]", "", 39, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.Ta1", "[s]", 40, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.Ta2", "[s]", 41, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.Tv", "[s]", 42, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.Te", "[s]", 43, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("kinematicPTP.noWphase", "[:#(type=Boolean)]", 44, false, \
0.0,0.0,0.0,0,2563)
DeclareParameter("integrator.k", "Integrator gain [1]", 34, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("integrator.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 45, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("integrator.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 46, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("integrator.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 47, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("integrator.y_start", "Initial or guess value of output (= state) [rad/s]",\
 35, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("integrator.u", "Connector of Real input signal", "kinematicPTP.y[1]", 1,\
 5, 53, 0)
DeclareState("integrator.y", "Connector of Real output signal [rad/s]", 5, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("integrator.der(y)", "der(Connector of Real output signal) [rad/s2]",\
 5, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("integrator.local_reset", "[:#(type=Boolean)]", 48, false, \
0.0,0.0,0.0,0,1539)
DeclareVariable("integrator.local_set", "", 49, 0, 0.0,0.0,0.0,0,1537)
DeclareAlias2("speedSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 1, 1, 4)
DeclareAlias2("speedSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "inertia1.w", 1, 1, 2, 4)
DeclareVariable("speedSensor.flange.tau", "Cut torque in the flange [N.m]", 50, 0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "inertia1.w", 1, 1, 2, 0)
DeclareVariable("loadTorque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 51, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("loadTorque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia2.phi", 1, 5, 70, 4)
DeclareAlias2("loadTorque.flange.tau", "Cut torque in the flange [N.m]", \
"loadTorque.tau_constant", -1, 7, 36, 132)
DeclareVariable("loadTorque.phi_support", "Absolute angle of support flange [rad|deg]",\
 52, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("loadTorque.phi", "Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 "inertia2.phi", 1, 5, 70, 0)
DeclareAlias2("loadTorque.der(phi)", "der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "inertia2.w", 1, 5, 71, 0)
DeclareParameter("loadTorque.tau_constant", "Constant torque (if negative, torque is acting as load in positive direction of rotation) [N.m]",\
 36, 10, 0.0,0.0,0.0,0,560)
DeclareAlias2("loadTorque.w", "Angular velocity of flange with respect to support (= der(phi)) [rad/s]",\
 "inertia2.w", 1, 5, 71, 0)
DeclareAlias2("loadTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "loadTorque.tau_constant", 1, 7, 36, 0)
DeclareOutput("CPUtime", "[s]", 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("EventCounter", "", 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.initialization[1].Calls", "Number of calls to solve this system",\
 73, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.initialization[1].Residues", "Number of evaluations of the system residual",\
 74, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.initialization[1].Iterations", \
"Number of iterations performed to solve this system", 75, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("NonlinearSystems.initialization[1].Jacobians", "Number of evaluations of the analytic system Jacobian",\
 76, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,61);
else if (DYNHReject) DYNX(W_,61)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,61);
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,72), 0.0, 1);
DoRemember_(DYNX(W_,66), 0, 0);
EndEqBlock
EndDataBlock
BreakSectionStart(1);
DYNX(W_,61) = DYNX(W_,55);
BreakSectionEnd()
